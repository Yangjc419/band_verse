# **Bandverse（乐队宇宙）社区版 - 软件设计文档**

## **1. 项目概述**

### **1.1 项目背景**
Bandverse（乐队宇宙）是一个社区驱动的音乐发现平台，专注于乐队文化的分享与交流。本应用将用户从被动的内容消费者转变为主动的内容创造者，通过每日推荐机制连接全球乐队爱好者。

### **1.2 核心价值**
- **社区驱动**：所有推荐内容由用户产生，形成真实、多元的音乐分享生态
- **社交属性**：展示推荐人信息，增强用户归属感和互动性
- **每日发现**：每天从用户推荐中随机选择一首歌、一句歌词、一个乐队，推荐给所有用户
- **低运营成本**：用户产生内容，平台只需提供技术支持和社区治理

### **1.3 技术架构**
- **前端**：Android原生开发（Kotlin + Jetpack Compose）
- **后端**：Supabase（PostgreSQL数据库 + 实时API + 认证服务）
- **推荐引擎**：n8n工作流引擎（每日随机推荐）
- **部署**：Supabase云服务 + n8n云服务

---

## **2. 系统架构设计**

### **2.1 整体架构**
```
Android客户端 (Kotlin)
↓ (Supabase Kotlin SDK)
Supabase服务层
├── PostgreSQL数据库
├── Realtime实时订阅
├── Edge Functions
└── Auth认证服务
↓ (HTTP Webhook)
n8n 每日推荐工作流
├── 随机选择用户推荐
├── 生成每日推荐
└── 写入推荐记录
↑ (API调用)
Android客户端展示推荐
```

### **2.2 核心数据流**
1. 用户通过App提交推荐（歌曲+歌词+乐队+推荐理由）
2. 推荐内容存入Supabase的`user_recommendations`表
3. 每日凌晨，n8n定时触发推荐工作流
4. n8n从所有用户推荐中随机选择一条
5. n8n将选中的推荐写入`daily_recommendations`表
6. Android客户端查询当日推荐，展示给所有用户
7. 推荐人的头像和用户名在推荐卡片中展示

---

## **3. 数据库设计**

### **3.1 核心数据表**

#### **用户表 (profiles)**
```sql
CREATE TABLE profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username TEXT UNIQUE NOT NULL,
  email TEXT UNIQUE,
  avatar_url TEXT,
  bio TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
```

#### **乐队表 (bands)**
```sql
CREATE TABLE bands (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  formation_year INTEGER,
  country TEXT,
  city TEXT,
  bio TEXT,
  image_url TEXT,
  genres JSONB NOT NULL,
  status TEXT DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT now()
);
```

#### **专辑表 (albums)**
```sql
CREATE TABLE albums (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  band_id UUID REFERENCES bands(id) NOT NULL,
  title TEXT NOT NULL,
  release_year INTEGER,
  cover_url TEXT,
  type TEXT DEFAULT 'album',
  created_at TIMESTAMPTZ DEFAULT now()
);
```

#### **歌曲表 (songs)**
```sql
CREATE TABLE songs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  album_id UUID REFERENCES albums(id) NOT NULL,
  title TEXT NOT NULL,
  duration INTEGER,
  lyrics TEXT,
  spotify_url TEXT,
  youtube_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

#### **用户推荐表 (user_recommendations)**
```sql
CREATE TABLE user_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(id) NOT NULL,
  song_id UUID REFERENCES songs(id) NOT NULL,
  lyric TEXT NOT NULL,
  band_id UUID REFERENCES bands(id) NOT NULL,
  recommendation_reason TEXT,
  status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- 创建索引优化查询性能
CREATE INDEX idx_user_recommendations_user_id ON user_recommendations(user_id);
CREATE INDEX idx_user_recommendations_song_id ON user_recommendations(song_id);
CREATE INDEX idx_user_recommendations_status ON user_recommendations(status);
CREATE INDEX idx_user_recommendations_created_at ON user_recommendations(created_at);
```

#### **每日推荐表 (daily_recommendations)**
```sql
CREATE TABLE daily_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  recommended_date DATE NOT NULL,
  user_recommendation_id UUID REFERENCES user_recommendations(id) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(recommended_date)
);

-- 创建索引优化查询性能
CREATE INDEX idx_daily_recommendations_date ON daily_recommendations(recommended_date);
```

#### **推荐互动表 (recommendation_interactions)**
```sql
CREATE TABLE recommendation_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(id) NOT NULL,
  recommendation_id UUID REFERENCES daily_recommendations(id) NOT NULL,
  interaction_type TEXT NOT NULL, -- 'like', 'comment', 'share'
  content TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id, recommendation_id, interaction_type)
);
```

---

## **4. n8n每日推荐工作流设计**

### **4.1 工作流触发机制**
- **触发方式**：定时触发器（每天凌晨2点）
- **执行频率**：每天一次
- **推荐策略**：从所有用户推荐中随机选择一条

### **4.2 推荐生成逻辑**

#### **步骤1：检查今日是否已有推荐**
```javascript
const today = new Date().toISOString().split('T')[0];
const existingRecommendation = await supabase
  .from('daily_recommendations')
  .select('*')
  .eq('recommended_date', today)
  .single();

if (existingRecommendation) {
  console.log('今日已有推荐，跳过生成');
  return;
}
```

#### **步骤2：随机选择用户推荐**
```javascript
// 从已审核的用户推荐中随机选择一条
const randomRecommendation = await supabase
  .from('user_recommendations')
  .select('*, profiles(username, avatar_url)')
  .eq('status', 'approved')
  .order('random()')
  .limit(1)
  .single();

if (!randomRecommendation) {
  console.log('没有可用的用户推荐，使用备用推荐');
  await generateFallbackRecommendation();
  return;
}
```

#### **步骤3：保存每日推荐**
```javascript
// 将选中的推荐保存为今日推荐
await supabase
  .from('daily_recommendations')
  .insert({
    recommended_date: today,
    user_recommendation_id: randomRecommendation.id
  });

console.log('今日推荐已生成：', randomRecommendation.id);
```

#### **步骤4：备用推荐方案**
```javascript
async function generateFallbackRecommendation() {
  // 从数据库中随机选择一首带歌词的歌曲
  const randomSong = await supabase
    .from('songs')
    .select('*, albums(*, bands(*))')
    .not('lyrics', 'is', null)
    .order('random()')
    .limit(1)
    .single();

  if (!randomSong) {
    console.log('没有可用的歌曲数据');
    return;
  }

  // 从歌词中随机选择一句
  const lyrics = randomSong.lyrics.split('\n').filter(line => line.trim().length > 10);
  const randomLyric = lyrics[Math.floor(Math.random() * lyrics.length)];

  // 创建系统推荐记录
  const systemRecommendation = await supabase
    .from('user_recommendations')
    .insert({
      user_id: '00000000-0000-0000-0000-000000000000', // 系统用户ID
      song_id: randomSong.id,
      lyric: randomLyric,
      band_id: randomSong.albums.bands.id,
      recommendation_reason: '系统推荐',
      status: 'approved'
    })
    .select()
    .single();

  // 保存为今日推荐
  await supabase
    .from('daily_recommendations')
    .insert({
      recommended_date: today,
      user_recommendation_id: systemRecommendation.id
    });
}
```

### **4.3 工作流优化**
- **错误重试机制**：配置n8n工作流失败时自动重试3次
- **日志记录**：记录每次推荐的执行结果和选择内容
- **性能监控**：监控工作流执行时间和资源消耗

---

## **5. Android客户端设计**

### **5.1 核心页面**

#### **首页 (HomeFragment)**
```kotlin
@Composable
fun HomeScreen() {
    val todayRecommendation by remember { loadTodayRecommendation() }
    
    if (todayRecommendation == null) {
        // 加载状态
        LoadingIndicator()
    } else {
        // 推荐卡片
        DailyRecommendationCard(recommendation = todayRecommendation)
    }
}
```

#### **推荐卡片组件**
```kotlin
@Composable
fun DailyRecommendationCard(recommendation: DailyRecommendation) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // 推荐人头像和用户名
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.padding(bottom = 16.dp)
            ) {
                AsyncImage(
                    model = recommendation.user.avatarUrl,
                    contentDescription = "推荐人头像",
                    modifier = Modifier
                        .size(40.dp)
                        .clip(CircleShape),
                    contentScale = ContentScale.Crop
                )
                Spacer(modifier = Modifier.width(12.dp))
                Text(
                    text = recommendation.user.username,
                    fontWeight = FontWeight.Bold,
                    fontSize = 16.sp
                )
            }
            
            // 推荐歌词
            Text(
                text = ""${recommendation.lyric}"",
                fontStyle = FontStyle.Italic,
                fontSize = 18.sp,
                lineHeight = 24.sp,
                modifier = Modifier.padding(bottom = 16.dp)
            )
            
            // 歌曲和乐队信息
            Text(
                text = "出自：${recommendation.song.title}",
                fontSize = 14.sp,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                modifier = Modifier.padding(bottom = 4.dp)
            )
            
            Text(
                text = "乐队：${recommendation.band.name}",
                fontSize = 14.sp,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                modifier = Modifier.padding(bottom = 16.dp)
            )
            
            // 推荐理由
            if (!recommendation.reason.isNullOrEmpty()) {
                Text(
                    text = recommendation.reason,
                    fontSize = 14.sp,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                    modifier = Modifier.padding(bottom = 16.dp)
                )
            }
            
            // 互动按钮（点赞、评论、分享）
            RecommendationActions(recommendation = recommendation)
        }
    }
}
```

#### **创建推荐页面 (CreateRecommendationActivity)**
```kotlin
@Composable
fun CreateRecommendationScreen() {
    var selectedSong by remember { mutableStateOf<Song?>(null) }
    var selectedLyric by remember { mutableStateOf("") }
    var reason by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // 选择歌曲
        SongSelector(
            onSongSelected = { song ->
                selectedSong = song
                selectedLyric = song.lyrics.lines().firstOrNull { it.isNotBlank() } ?: ""
            }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 选择歌词
        if (selectedSong != null) {
            LyricPicker(
                lyrics = selectedSong!!.lyrics,
                selectedLyric = selectedLyric,
                onLyricSelected = { lyric -> selectedLyric = lyric }
            )
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 推荐理由
        TextField(
            value = reason,
            onValueChange = { reason = it },
            label = { Text("推荐理由（选填）") },
            modifier = Modifier.fillMaxWidth(),
            maxLines = 3
        )
        
        Spacer(modifier = Modifier.height(24.dp))
        
        // 提交按钮
        Button(
            onClick = {
                isLoading = true
                submitRecommendation(
                    songId = selectedSong?.id,
                    lyric = selectedLyric,
                    reason = reason
                )
            },
            modifier = Modifier.fillMaxWidth(),
            enabled = selectedSong != null && selectedLyric.isNotBlank() && !isLoading
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.size(20.dp),
                    color = MaterialTheme.colorScheme.onPrimary
                )
            } else {
                Text("提交推荐")
            }
        }
    }
}
```

#### **推荐历史页面 (RecommendationHistoryFragment)**
```kotlin
@Composable
fun RecommendationHistoryScreen() {
    val recommendations by remember { loadRecommendationHistory() }
    
    LazyColumn {
        items(recommendations) { recommendation ->
            RecommendationHistoryItem(recommendation = recommendation)
            Divider()
        }
    }
}
```

### **5.2 数据层实现**

#### **数据模型**
```kotlin
data class DailyRecommendation(
    val id: String,
    val recommendedDate: String,
    val lyric: String,
    val song: Song,
    val band: Band,
    val reason: String?,
    val user: User,
    val createdAt: String
)

data class User(
    val id: String,
    val username: String,
    val avatarUrl: String?
)

data class Song(
    val id: String,
    val title: String,
    val lyrics: String,
    val album: Album
)

data class Band(
    val id: String,
    val name: String,
    val imageUrl: String?
)
```

#### **数据获取逻辑**
```kotlin
class RecommendationRepository {
    suspend fun getTodayRecommendation(): DailyRecommendation? {
        val today = LocalDate.now().toString()
        
        return supabase
            .from("daily_recommendations")
            .select("*, user_recommendations!inner(*, profiles!inner(*), songs!inner(*, albums!inner(*, bands!inner(*))))")
            .eq("recommended_date", today)
            .single()
            .decodeSingle<DailyRecommendation>()
    }
    
    suspend fun submitRecommendation(
        userId: String,
        songId: String,
        lyric: String,
        reason: String?
    ): Result<String> {
        return try {
            val bandId = supabase
                .from("songs")
                .select("albums(band_id)")
                .eq("id", songId)
                .single()
                .decodeSingle<Map<String, Any>>()
                .get("albums") as Map<String, String>
                .get("band_id") as String
            
            val result = supabase
                .from("user_recommendations")
                .insert(
                    mapOf(
                        "user_id" to userId,
                        "song_id" to songId,
                        "lyric" to lyric,
                        "band_id" to bandId,
                        "recommendation_reason" to reason
                    )
                )
                .select()
                .single()
            
            Result.success(result.id)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

---

## **6. 接口设计**

### **6.1 Supabase RPC函数**

#### **获取今日推荐**
```sql
CREATE OR REPLACE FUNCTION get_today_recommendation()
RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'id', dr.id,
    'recommended_date', dr.recommended_date,
    'lyric', ur.lyric,
    'reason', ur.recommendation_reason,
    'song', (SELECT row_to_json(s) FROM songs s WHERE s.id = ur.song_id),
    'band', (SELECT row_to_json(b) FROM bands b WHERE b.id = ur.band_id),
    'user', (SELECT row_to_json(p) FROM profiles p WHERE p.id = ur.user_id)
  ) INTO result
  FROM daily_recommendations dr
  JOIN user_recommendations ur ON dr.user_recommendation_id = ur.id
  WHERE dr.recommended_date = CURRENT_DATE;
  
  RETURN COALESCE(result, '{}'::JSONB);
END;
$$ LANGUAGE plpgsql;
```

#### **获取用户推荐历史**
```sql
CREATE OR REPLACE FUNCTION get_user_recommendations(user_id UUID)
RETURNS TABLE (
  id UUID,
  lyric TEXT,
  recommendation_reason TEXT,
  song JSONB,
  band JSONB,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ur.id,
    ur.lyric,
    ur.recommendation_reason,
    (SELECT row_to_json(s) FROM songs s WHERE s.id = ur.song_id),
    (SELECT row_to_json(b) FROM bands b WHERE b.id = ur.band_id),
    ur.created_at
  FROM user_recommendations ur
  WHERE ur.user_id = user_id
  ORDER BY ur.created_at DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## **7. 性能优化策略**

### **7.1 数据库优化**
- 为所有外键字段创建索引
- 为查询频繁的字段（如`recommended_date`、`status`）创建索引
- 使用行级安全策略（RLS）控制数据访问权限
- 定期清理过期数据（如保留最近180天的推荐记录）

### **7.2 客户端优化**
- 图片懒加载和缓存（Glide/Coil）
- 数据分页加载（Paging 3库）
- 网络请求合并和去重
- 离线数据缓存（Room数据库）

### **7.3 n8n工作流优化**
- 批量操作优化：使用Supabase的批量插入/更新API
- 错误重试机制：配置合理的超时和重试次数
- 日志记录：记录每次推荐的内容和执行结果

---

## **8. 开发计划**

### **阶段一：基础版本（2周）**
- ✅ Supabase项目搭建和数据库设计
- ✅ Android基础框架搭建
- ✅ 用户认证和登录功能
- ✅ 基础数据展示（乐队列表、详情）

### **阶段二：推荐功能（2周）**
- ✅ n8n工作流部署和配置
- ✅ 用户推荐提交功能
- ✅ 每日随机推荐算法实现
- ✅ 推荐展示页面开发

### **阶段三：功能完善（1周）**
- ✅ 推荐历史查看
- ✅ 互动功能（点赞、评论）
- ✅ 性能优化和测试
- ✅ 部署上线

---

## **9. 风险与应对**

### **技术风险**
- **n8n工作流执行失败**：增加错误日志和重试机制
- **推荐内容质量参差不齐**：初期可手动审核，后期引入社区投票机制
- **Supabase配额限制**：监控使用量，必要时升级套餐

### **运营风险**
- **初期用户参与度低**：设计激励机制（推荐排行榜、成就系统）
- **内容重复推荐**：实现去重逻辑，避免短期内重复推荐同一乐队或歌曲
- **版权问题**：仅存储歌词片段和元数据，不存储完整音频文件

---

**文档版本**: v3.0（社区版）  
**最后更新**: 2026-01-13  
**备注**: 本版本将Bandverse从工具型应用转变为社区驱动平台，核心功能由用户推荐和每日随机推荐构成，强调社区参与和社交属性。